import ValueIO;
import analysis::graphs::Graph;
import DataStructures;



TODO: fix names.
tuple[Graph[Vertex] calls, set[Vertex] escaping, set[Vertex] unresolved] pessPdf = readBinaryValueFile(#tuple[Graph[Vertex], set[Vertex] ,set[Vertex]], |file:///home/sander/Dropbox/Afstuderen%20UvA/graphs/untitled/src/verwerkt/pdfjs/pessimisticPacman.bin|);
Graph[Vertex] optPdf = readBinaryValueFile(#Graph[Vertex], |file:///home/sander/Dropbox/Afstuderen%20UvA/graphs/untitled/src/verwerkt/pdfjs/optimisticPacman.bin|);

loc pdfCallMapLoc = |file:///home/sander/Dropbox/Afstuderen%20UvA/graphs/untitled/src/verwerkt/pdfjs/callgraph.json|;
printStatistics(pessPdf.calls, pdfCallMapLoc);
printStatistics(optPdf, pdfCallMapLoc);

dynPdf = convertJsonToGraph(pdfCallMapLoc);
possibleIncorrectPdf = generatePossibleIncorrectCallbackEdges([|file:///home/sander/Dropbox/Afstuderen%20UvA/graphs/untitled/src/verwerkt/pdfjs/prepared/build/pdf.js|]);
----
IDENTIFIED FALSE POSITIVES:
dynPdf - (dynPdf - possibleIncorrectPdf)
Graph[str]: {
  <"Callee(pdf.js@1796:73906-73951)","Func(pdf.js@1669:68849-69329)">, //false positive, because of the field-based approach the "this" becomes this.ctx. This is actually a call to the transform function via apply which is not recognized by the static call graph algo.
  <"Callee(pdf.js@101321:2529642-2529771)","Func(pdf.js@101321:2529659-2529770)">, //correct, funcExpr
  <"Callee(pdf.js@99899:2471272-2471401)","Func(pdf.js@99899:2471284-2471400)">, //correct, funcExpr
  <"Callee(pdf.js@424:19951-20091)","Func(pdf.js@424:19972-20090)">, //correct, funcExpr
  <"Callee(pdf.js@98997:2423061-2423175)","Func(pdf.js@98997:2423072-2423174)">, //correct, funcExpr
  <"Callee(pdf.js@101067:2518240-2518351)","Func(pdf.js@101067:2518257-2518350)">, //correct, funcExpr
  <"Callee(pdf.js@629:27137-27309)","Func(pdf.js@625:27011-27104)">, //correct, direct function reference spanning over 10 lines.
  <"Callee(pdf.js@634:27322-27494)","Func(pdf.js@625:27011-27104)">, //correct, direct function reference
  <"Callee(pdf.js@99254:2436077-2436267)","Func(pdf.js@99254:2436090-2436266)">, //correct, funcExpr
  <"Callee(pdf.js@1342:52925-52947)","Func(pdf.js@1347:53106-53594)"> //correct, direct function reference
}

spurious = {
  <"Callee(pdf.js@101321:2529642-2529771)","Func(pdf.js@101321:2529659-2529770)">,
  <"Callee(pdf.js@99899:2471272-2471401)","Func(pdf.js@99899:2471284-2471400)">,
  <"Callee(pdf.js@424:19951-20091)","Func(pdf.js@424:19972-20090)">,
  <"Callee(pdf.js@98997:2423061-2423175)","Func(pdf.js@98997:2423072-2423174)">,
  <"Callee(pdf.js@101067:2518240-2518351)","Func(pdf.js@101067:2518257-2518350)">,
  <"Callee(pdf.js@629:27137-27309)","Func(pdf.js@625:27011-27104)">,
  <"Callee(pdf.js@634:27322-27494)","Func(pdf.js@625:27011-27104)">,
  <"Callee(pdf.js@99254:2436077-2436267)","Func(pdf.js@99254:2436090-2436266)">,
  <"Callee(pdf.js@1342:52925-52947)","Func(pdf.js@1347:53106-53594)">
};
missing = generatePossibleMissingEdges(spurious, ("pdf.js":readFile(|file:///home/sander/Dropbox/Afstuderen%20UvA/graphs/untitled/src/verwerkt/pdfjs/prepared/build/pdf.js|)));

stringPdfPes = convertVertexGraphToStringGraph(pessPdf.calls)
printStatistics(stringPdfPes, (dynPdf - spurious) + missing);
----

Met natives:

The precision is 73.3752620500%
The recall is 84.1346153800%
ok


--------
staticCG = {tup | tuple[str callee, str target] tup <- stringPdfPes, tup.callee in callees};
diff = staticCG - dynPdf;
callsToPushFunctions = {tup | tuple[str callee, str func] tup <- diff, tup.func == "Func(pdf.js@3678:166096-166327)"}

rascal>size(staticCG - dynPdf)
int: 2382
